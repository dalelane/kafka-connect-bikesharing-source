/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.ibm.eventautomation.demos.bikesharing.generators;

import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.time.Year;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Queue;
import java.util.stream.Collectors;

import org.apache.kafka.common.config.AbstractConfig;
import org.apache.kafka.connect.source.SourceRecord;
import org.apache.kafka.connect.source.SourceTaskContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ibm.eventautomation.demos.bikesharing.DatagenSourceConfig;
import com.ibm.eventautomation.demos.bikesharing.data.CachedDataItem;
import com.ibm.eventautomation.demos.bikesharing.data.HourData;
import com.ibm.eventautomation.demos.bikesharing.data.RawHourData;
import com.ibm.eventautomation.demos.bikesharing.exceptions.BikeSharingDataException;
import com.ibm.eventautomation.demos.bikesharing.utils.OffsetManagement;
import com.ibm.eventautomation.demos.bikesharing.utils.Store;
import com.opencsv.bean.CsvToBeanBuilder;


/**
 * Generic generator for creating events derived from the "hour.csv" CSV file.
 *
 * The type of event generated is defined by the generic class.
 * The events are generated by the abstract itemFactory - the job of this abstract
 *  class is to parse the CSV file and provide the methods to drive getting the
 *  next available record for Kafka.
 */
public abstract class Generator<T extends CachedDataItem> {

    private static final Logger log = LoggerFactory.getLogger(Generator.class);

    private static final String DATA_SOURCE_FILE = "data/hour.csv";

    private final Store<T> cache;
    private final Queue<SourceRecord> records;

    /** formatter for event timestamps */
    private final DateTimeFormatter timestampFormatter;

    /** years to deduct from timestamps that are generated */
    protected final int datasetYearsOffset;
    /** years to deduct from current time used for comparisons */
    protected final int nowYearsOffset;

    private final static int DATASET_YEAR_START = 2011;

    protected Generator(AbstractConfig config, Queue<SourceRecord> connectRecords) throws BikeSharingDataException {
        timestampFormatter = DateTimeFormatter.ofPattern(config.getString(DatagenSourceConfig.CONFIG_FORMATS_TIMESTAMPS));
        datasetYearsOffset = config.getBoolean(DatagenSourceConfig.CONFIG_DATE_SHIFT) ?
                                // update timestamps to look like live data
                                Year.now().getValue() - DATASET_YEAR_START :
                                // use the dataset data as-is
                                0;
        nowYearsOffset = config.getBoolean(DatagenSourceConfig.CONFIG_DATE_SHIFT) ?
                            // treating data as live / real-time
                            0 :
                            // shift timestamps to match dataset
                            Year.now().getValue() - DATASET_YEAR_START;

        this.cache = getCachedData();
        this.records = connectRecords;
    }

    /**
     * If the Connector is running for the first time, this will generate a simplified history
     *  of events from the start of the year up until the current time.
     */
    protected void initialise(SourceTaskContext context, Map<String, String> sourcePartition) {
        log.debug("initialise");
        boolean firstRun = OffsetManagement.hasStoredOffset(context, sourcePartition) == false;
        log.debug("first run {}", firstRun);
        if (firstRun) {
            List<T> historicalData = cache.history();
            log.debug("number of items to init {}", historicalData.size());
            for (T historicalItem : historicalData) {
                processNextItem(historicalItem);
            }
        }
    }

    protected abstract void processNextItem(T item);

    protected abstract T itemFactory(HourData raw);

    protected T nextItem() throws NoSuchElementException {
        return cache.get();
    }
    protected T peek() {
        return cache.peek();
    }

    protected void queue(SourceRecord record) {
        records.add(record);
    }

    protected DateTimeFormatter getTimestampFormatter() {
        return timestampFormatter;
    }

    private Store<T> getCachedData() throws BikeSharingDataException {
        try (Reader reader = new InputStreamReader(getClass().getClassLoader().getResourceAsStream(DATA_SOURCE_FILE))) {
            return new Store<>(new CsvToBeanBuilder<RawHourData>(reader)
                                    .withType(RawHourData.class)
                                    .build().parse().stream()
                                    .map(raw -> new HourData(raw, datasetYearsOffset))
                                    .map(all -> itemFactory(all))
                                    .collect(Collectors.toList()),
                               nowYearsOffset);
        }
        catch (IOException exc) {
            throw new BikeSharingDataException(exc);
        }
    }
}
